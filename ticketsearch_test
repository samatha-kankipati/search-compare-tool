upstream tsearch_test  {
  server node1.test.search.api.rackspace.com:8080 max_fails=2 fail_timeout=15s;
  server node2.test.search.api.rackspace.com:8080 max_fails=2 fail_timeout=15s; 

}

server {
  listen 80;
  server_name test.search.api.rackspace.com;

  location / {
  # Use next upstream on http error, http timeout, or http 500 response
  # NOTE: Remove http_500 if your production/staging/dev nodes
  # produce 500's _EVER_ during requests.
  # otherwise imagine a production node that returns 500, then the
  # request hits all your other nodes and you attack your nodes with
  # requests because your application returns those errors.
  # See the docs for more rules you can apply for proxy_next_upstream
  # Docs: http://wiki.nginx.org/HttpProxyModule#proxy_next_upstream
  proxy_next_upstream error timeout http_500 http_502 http_503 http_504 http_404;

  # If socket not responding in X seconds, timeout=True
  proxy_connect_timeout 5;
  # If remote socket doesn't send data within X seconds, timeout=True
  proxy_read_timeout 5;


    proxy_pass  http://tsearch_test;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }

}

upstream tsearch_elastic_test  {
  server node1.test.search.api.rackspace.com:9200 max_fails=1 fail_timeout=15s;
  server node2.test.search.api.rackspace.com:9200 max_fails=1 fail_timeout=15s;
}

server {
  listen 80;
  server_name test.elastic.search.api.rackspace.com;

  location / {
    # Use next upstream on http error, http timeout, or http 500 response
    # NOTE: Remove http_500 if your production/staging/dev nodes
    # produce 500's _EVER_ during requests.
    # otherwise imagine a production node that returns 500, then the
    # request hits all your other nodes and you attack your nodes with
    # requests because your application returns those errors.
    # See the docs for more rules you can apply for proxy_next_upstream
    # Docs: http://wiki.nginx.org/HttpProxyModule#proxy_next_upstream
    proxy_next_upstream error timeout http_500 http_502 http_503 http_504 http_404;

    # If socket not responding in X seconds, timeout=True
    proxy_connect_timeout 10;
    # If remote socket doesn't send data within X seconds, timeout=True
    proxy_read_timeout 10;

    proxy_pass  http://tsearch_elastic_test;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }



  location /_plugin/ {
    # Use next upstream on http error, http timeout, or http 500 response
    # NOTE: Remove http_500 if your production/staging/dev nodes
    # produce 500's _EVER_ during requests.
    # otherwise imagine a production node that returns 500, then the
    # request hits all your other nodes and you attack your nodes with
    # requests because your application returns those errors.
    # See the docs for more rules you can apply for proxy_next_upstream
    # Docs: http://wiki.nginx.org/HttpProxyModule#proxy_next_upstream
    proxy_next_upstream error timeout http_500 http_502 http_503 http_504 http_404;

    # If socket not responding in X seconds, timeout=True
    proxy_connect_timeout 10;
    # If remote socket doesn't send data within X seconds, timeout=True
    proxy_read_timeout 10;

    proxy_pass  http://tsearch_test;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }

}
